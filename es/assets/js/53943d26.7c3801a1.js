"use strict";(globalThis.webpackChunkserenity_users_guide=globalThis.webpackChunkserenity_users_guide||[]).push([[4341],{3463(e,a,n){n.d(a,{A:()=>s});const s=n.p+"assets/images/find-a-user-by-id-027d199be318af7f5c3207b9d63806ba.png"},5023(e,a,n){n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>t,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"screenplay/screenplay_rest","title":"Trabajando con APIs REST usando Serenity Screenplay","description":"El Screenplay Pattern es un enfoque para escribir pruebas de aceptacion automatizadas que nos ayuda a escribir codigo de automatizacion mas limpio, mantenible y escalable. Un test Screenplay habla primero y principalmente sobre los Task que un usuario realiza, en lenguaje de negocio, en lugar de sumergirse en los detalles sobre botones, clics y campos de entrada. Enfocarse en los Task de negocio hace que nuestros tests sean mas legibles, mas mantenibles y mas faciles de escalar.","source":"@site/i18n/es/docusaurus-plugin-content-docs/current/screenplay/screenplay-rest.md","sourceDirName":"screenplay","slug":"/screenplay/screenplay_rest","permalink":"/es/docs/screenplay/screenplay_rest","draft":false,"unlisted":false,"editUrl":"https://github.com/serenity-bdd/serenity-bdd.github.io/blob/master/docs/screenplay/screenplay-rest.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"screenplay_rest","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Pruebas Web con Serenity Screenplay y Playwright","permalink":"/es/docs/screenplay/screenplay_playwright"},"next":{"title":"Haciendo Aserciones en Screenplay con Serenity Ensure","permalink":"/es/docs/screenplay/screenplay_ensure"}}');var r=n(4848),o=n(8453);const i={id:"screenplay_rest",sidebar_position:3},t="Trabajando con APIs REST usando Serenity Screenplay",l={},d=[{value:"Configurando tu proyecto",id:"configurando-tu-proyecto",level:2},{value:"Definiendo una URI base",id:"definiendo-una-uri-base",level:2},{value:"Leyendo desde el archivo de configuracion de Serenity",id:"leyendo-desde-el-archivo-de-configuracion-de-serenity",level:3},{value:"Configurando la URL de la API desde la linea de comandos",id:"configurando-la-url-de-la-api-desde-la-linea-de-comandos",level:3},{value:"Configurando la URL base de la API en Maven",id:"configurando-la-url-base-de-la-api-en-maven",level:3},{value:"Configurando el Actor - la Ability CallAnApi",id:"configurando-el-actor---la-ability-callanapi",level:2},{value:"Interaction GET",id:"interaction-get",level:2},{value:"Peticiones GET simples",id:"peticiones-get-simples",level:3},{value:"Recuperando objetos",id:"recuperando-objetos",level:3},{value:"Recuperando listas",id:"recuperando-listas",level:3},{value:"Usando Parametros de Ruta",id:"usando-parametros-de-ruta",level:3},{value:"Usando Parametros de Consulta",id:"usando-parametros-de-consulta",level:3},{value:"Consultas Post",id:"consultas-post",level:2},{value:"Otros tipos de consultas",id:"otros-tipos-de-consultas",level:2},{value:"Task de nivel superior",id:"task-de-nivel-superior",level:2}];function c(e){const a={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.header,{children:(0,r.jsx)(a.h1,{id:"trabajando-con-apis-rest-usando-serenity-screenplay",children:"Trabajando con APIs REST usando Serenity Screenplay"})}),"\n",(0,r.jsx)(a.p,{children:"El Screenplay Pattern es un enfoque para escribir pruebas de aceptacion automatizadas que nos ayuda a escribir codigo de automatizacion mas limpio, mantenible y escalable. Un test Screenplay habla primero y principalmente sobre los Task que un usuario realiza, en lenguaje de negocio, en lugar de sumergirse en los detalles sobre botones, clics y campos de entrada. Enfocarse en los Task de negocio hace que nuestros tests sean mas legibles, mas mantenibles y mas faciles de escalar."}),"\n",(0,r.jsx)(a.p,{children:'Screenplay a menudo se asocia con pruebas de UI. Curiosamente, el nombre del patron en realidad no esta relacionado con pantallas o interfaces de usuario; proviene de una metafora teatral, donde los actores interpretan roles en un escenario siguiendo un guion predefinido (el "screenplay"), y fue acunado por Antony Marcano y Andy Palmer alrededor de 2015. El patron en si se remonta mas atras, y ha existido en varias formas desde que fue propuesto por primera vez por Antony Marcano en 2007.'}),"\n",(0,r.jsx)(a.p,{children:"Pero Screenplay tambien es una excelente opcion para pruebas de API o servicios web. En particular, Screenplay es ideal cuando queremos incluir actividades de API y UI en el mismo test. Por ejemplo, podriamos tener un Task de API para configurar algunos datos de prueba, un Task de UI para ilustrar como un usuario interactua con estos datos, y luego otro Task de API para verificar el nuevo estado de la base de datos."}),"\n",(0,r.jsx)(a.p,{children:"Puedes tener una idea de como se ven las Interaction de API REST usando Serenity Screenplay aqui:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'@Test\npublic void list_all_users() {\n\n    Actor sam = Actor.named("Sam the supervisor")\n                     .whoCan(CallAnApi.at(theRestApiBaseUrl));\n\n    sam.attemptsTo(\n            Get.resource("/users")\n    );\n\n    sam.should(\n            seeThatResponse("all the expected users should be returned",\n                    response -> response.statusCode(200)\n                                        .body("data.first_name", hasItems("George", "Janet", "Emma")))\n    );\n}\n'})}),"\n",(0,r.jsxs)(a.p,{children:["Serenity Screenplay usa ",(0,r.jsx)(a.a,{href:"https://rest-assured.io",children:"Rest-Assured"})," para interactuar con endpoints REST, y para consultar las respuestas. Rest-Assured nos proporciona un DSL Java simple pero extremadamente poderoso que nos permite probar virtualmente cualquier tipo de endpoint REST. Su codigo altamente legible tambien es una opcion ideal para Screenplay."]}),"\n",(0,r.jsx)(a.h2,{id:"configurando-tu-proyecto",children:"Configurando tu proyecto"}),"\n",(0,r.jsxs)(a.p,{children:["Para probar servicios API REST con Screenplay, necesitas agregar la dependencia ",(0,r.jsx)(a.code,{children:"serenity-screenplay-rest"})," a tu proyecto. En Maven, agrega lo siguiente a las dependencias en tu archivo ",(0,r.jsx)(a.code,{children:"pom.xml"}),":"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-xml",children:"<dependency>\n    <groupId>net.serenity-bdd</groupId>\n    <artifactId>serenity-screenplay-rest</artifactId>\n    <version>${serenity.version}</version>\n    <scope>test</scope>\n</dependency>\n"})}),"\n",(0,r.jsxs)(a.p,{children:["Y para Gradle, puedes agregar la misma dependencia a tu archivo ",(0,r.jsx)(a.code,{children:"build.gradle"}),":"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-groovy",children:'testCompile "net.serenity-bdd:serenity-screenplay-rest:${serenityVersion}"\n'})}),"\n",(0,r.jsx)(a.h2,{id:"definiendo-una-uri-base",children:"Definiendo una URI base"}),"\n",(0,r.jsx)(a.p,{children:"Cuando pruebas una API REST, es conveniente poder usar los mismos tests contra diferentes entornos. Puedes querer ejecutar tus tests contra un servidor ejecutandose en tu maquina local, contra un servidor QA, o incluso contra una instancia de produccion. Y no quieres tener que cambiar tus tests cada vez que pruebas contra un entorno diferente."}),"\n",(0,r.jsxs)(a.p,{children:["Por ejemplo, en este capitulo, estaremos demostrando las caracteristicas de ",(0,r.jsx)(a.code,{children:"serenity-screenplay-rest"})," usando la aplicacion ",(0,r.jsx)(a.a,{href:"https://reqres.in",children:"ResReq"})," (ver abajo). Si tienes una conexion a internet confiable, puedes ejecutar tus tests contra el servidor ResReq en vivo en ",(0,r.jsx)(a.a,{href:"https://reqres.in/api/",children:"https://reqres.in/api/"}),". O si estas ejecutando el servidor ResReq localmente, accederias a los endpoints en ",(0,r.jsx)(a.a,{href:"http://localhost:5000/api",children:"http://localhost:5000/api"}),"."]}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.strong,{children:"La aplicacion de prueba ResReq"})}),"\n",(0,r.jsxs)(a.p,{children:["La aplicacion ",(0,r.jsx)(a.a,{href:"https://reqres.in",children:"ResReq"})," es una aplicacion de codigo abierto escrita por ",(0,r.jsx)(a.a,{href:"http://benhowdle.im/",children:"Ben Howdle"})," que facilita experimentar con APIs REST. Esta alojada en Digital Ocean, donde puedes acceder a ella en linea en ",(0,r.jsx)(a.a,{href:"https://reqres.in/api/",children:"https://reqres.in/api/"}),". Alternativamente, tambien puedes descargar la aplicacion desde el ",(0,r.jsx)(a.a,{href:"https://github.com/benhowdle89/reqres",children:"repositorio del proyecto en Github"}),", y ejecutarla localmente. Cuando ejecutas la aplicacion en tu propia maquina, la API REST estara disponible en ",(0,r.jsx)(a.a,{href:"http://localhost:5000/api",children:"http://localhost:5000/api"}),"."]}),"\n",(0,r.jsx)(a.h3,{id:"leyendo-desde-el-archivo-de-configuracion-de-serenity",children:"Leyendo desde el archivo de configuracion de Serenity"}),"\n",(0,r.jsxs)(a.p,{children:["En Serenity BDD, puedes definir la URL base para tu API REST directamente en el archivo ",(0,r.jsx)(a.code,{children:"serenity.properties"})," o ",(0,r.jsx)(a.code,{children:"serenity.conf"})," de tu proyecto.\nAqui hay un ejemplo de un archivo ",(0,r.jsx)(a.code,{children:"serenity.conf"}),":"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-json",children:'restapi {\n      baseurl = "https://reqres.in/api"\n}\n'})}),"\n",(0,r.jsxs)(a.p,{children:["Cualquier test puede leer valores de los archivos de configuracion de Serenity simplemente creando un campo de tipo ",(0,r.jsx)(a.code,{children:"EnvironmentVariables"})," en el test.\nLuego puedes obtener la propiedad, y proporcionar un valor por defecto para usar si la propiedad no ha sido definida, como se muestra a continuacion:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'theRestApiBaseUrl = environmentVariables.optionalProperty("restapi.baseurl")\n                                        .orElse("https://reqres.in/api");\n'})}),"\n",(0,r.jsx)(a.h3,{id:"configurando-la-url-de-la-api-desde-la-linea-de-comandos",children:"Configurando la URL de la API desde la linea de comandos"}),"\n",(0,r.jsx)(a.p,{children:"Puedes sobrescribir la URL por defecto definida de esta manera simplemente proporcionando una propiedad del sistema en la linea de comandos, asi:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{children:"mvn verify -Drestapi.baseurl=http://localhost:5000/api\n"})}),"\n",(0,r.jsx)(a.h3,{id:"configurando-la-url-base-de-la-api-en-maven",children:"Configurando la URL base de la API en Maven"}),"\n",(0,r.jsxs)(a.p,{children:["Si estas usando Maven, un enfoque mas conveniente puede ser usar ",(0,r.jsx)(a.a,{href:"http://maven.apache.org/guides/introduction/introduction-to-profiles.html",children:"Perfiles de Maven"}),".\nEn tu archivo ",(0,r.jsx)(a.code,{children:"pom.xml"}),", defines diferentes perfiles Maven para cada entorno, y configuras la propiedad ",(0,r.jsx)(a.code,{children:"restapi.baseurl"})," en consecuencia:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-xml",children:"<profiles>\n    <profile>\n        <id>dev</id>\n        <properties>\n            <restapi.baseurl>http://localhost:5000/api</restapi.baseurl>\n        </properties>\n    </profile>\n    <profile>\n        <id>prod</id>\n        <properties>\n            <restapi.baseurl>https://reqres.in/api</restapi.baseurl>\n        </properties>\n    </profile>\n</profiles>\n"})}),"\n",(0,r.jsxs)(a.p,{children:["Para que esto funcione correctamente, tambien necesitas asegurar que ",(0,r.jsx)(a.code,{children:"restapi.baseurl"})," se pase correctamente a tus tests.\nHaces esto usando la etiqueta ",(0,r.jsx)(a.code,{children:"systemPropertyVariables"})," en la configuracion del ",(0,r.jsx)(a.code,{children:"maven-failsafe-plugin"}),", como se muestra aqui:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-xml",children:"<build>\n    <plugins>\n        <plugin>\n            <artifactId>maven-failsafe-plugin</artifactId>\n            <version>2.20</version>\n            <configuration>\n                <includes>\n                    <include>**/When*.java</include>\n                    <include>**/*Feature.java</include>\n                </includes>\n                <systemPropertyVariables>\n                    <restapi.baseurl>${restapi.baseurl}</restapi.baseurl>\n                </systemPropertyVariables>\n            </configuration>\n            <executions>\n                <execution>\n                    <goals>\n                        <goal>integration-test</goal>\n                        <goal>verify</goal>\n                    </goals>\n                </execution>\n            </executions>\n        </plugin>\n        ...\n"})}),"\n",(0,r.jsxs)(a.p,{children:["Luego puedes ejecutar los tests con Maven usando la opcion ",(0,r.jsx)(a.code,{children:"-P"}),":"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{children:"$ mvn verify -Pdev\n"})}),"\n",(0,r.jsx)(a.h2,{id:"configurando-el-actor---la-ability-callanapi",children:"Configurando el Actor - la Ability CallAnApi"}),"\n",(0,r.jsxs)(a.p,{children:["En Screenplay, los tests describen el comportamiento en terminos de ",(0,r.jsx)(a.em,{children:"Actor"}),", que logran sus objetivos de negocio realizando ",(0,r.jsx)(a.em,{children:"Task"}),".\nEstos Task usualmente involucran ",(0,r.jsx)(a.em,{children:"interactuar"})," con la aplicacion de alguna manera.\nY para realizar estos Task, damos a los Actor varias ",(0,r.jsx)(a.em,{children:"Ability"})," (habilidades)."]}),"\n",(0,r.jsxs)(a.p,{children:["La Ability ",(0,r.jsx)(a.code,{children:"CallAnApi"})," da a los Actor la habilidad de interactuar con un servicio web REST usando ",(0,r.jsx)(a.a,{href:"https://rest-assured.io",children:"Rest-Assured"}),".\nEsto incluye tanto invocar endpoints REST como consultar los resultados."]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'private String theRestApiBaseUrl;\nprivate EnvironmentVariables environmentVariables;\nprivate Actor sam;\n\n@Before\npublic void configureBaseUrl() {\n    theRestApiBaseUrl = environmentVariables.optionalProperty("restapi.baseurl")\n                                                   .orElse("https://reqres.in/api");\n\n    sam = Actor.named("Sam the supervisor").whoCan(CallAnApi.at(theRestApiBaseUrl));\n}\n'})}),"\n",(0,r.jsxs)(a.p,{children:["La Ability ",(0,r.jsx)(a.code,{children:"CallAnApi"})," permite al Actor realizar las clases de Interaction REST incluidas en Serenity. Esto incluye:"]}),"\n",(0,r.jsxs)(a.ul,{children:["\n",(0,r.jsx)(a.li,{children:"Get.resource()"}),"\n",(0,r.jsx)(a.li,{children:"Post.to()"}),"\n",(0,r.jsx)(a.li,{children:"Put.to()"}),"\n",(0,r.jsx)(a.li,{children:"Delete.from()"}),"\n"]}),"\n",(0,r.jsxs)(a.p,{children:["La mas simple de estas es ",(0,r.jsx)(a.code,{children:"Get"}),"."]}),"\n",(0,r.jsx)(a.h2,{id:"interaction-get",children:"Interaction GET"}),"\n",(0,r.jsx)(a.p,{children:"En una API REST, las peticiones GET se usan para consultar un recurso REST.\nVeamos como podemos hacer esto usando Serenity Screenplay."}),"\n",(0,r.jsx)(a.h3,{id:"peticiones-get-simples",children:"Peticiones GET simples"}),"\n",(0,r.jsxs)(a.p,{children:["En nuestra aplicacion de demostracion, el recurso ",(0,r.jsx)(a.code,{children:"/users"})," representa los usuarios de la aplicacion.\nPodemos recuperar los detalles de un usuario particular agregando el ID del usuario, asi: ",(0,r.jsx)(a.code,{children:"/users/1"}),".\nLa estructura de un registro de usuario se muestra a continuacion:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-json",children:'{\n  "data": {\n    "id": 1,\n    "first_name": "George",\n    "last_name": "Bluth",\n    "avatar": "https://s3.amazonaws.com/uifaces/faces/twitter/calebogden/128.jpg"\n  }\n}\n'})}),"\n",(0,r.jsx)(a.p,{children:"Supongamos que necesitamos escribir un Scenario que recupera un usuario particular, y verifica algunos de los detalles del usuario, como first_name y last_name.\nTal test podria verse asi:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'@Test\npublic void find_an_individual_user() {\n\n    sam.attemptsTo(\n            Get.resource("/users/1")\n    );\n\n    sam.should(\n            seeThatResponse( "User details should be correct",\n                    response -> response.statusCode(200)\n                                        .body("data.first_name", equalTo("George"))\n                                        .body("data.last_name", equalTo("Bluth"))\n            )\n    );\n}\n'})}),"\n",(0,r.jsxs)(a.p,{children:["Como puedes ver, este codigo es bastante autoexplicativo.\nComo cualquier otro test Screenplay, usamos el metodo ",(0,r.jsx)(a.code,{children:"attemptsTo()"})," del Actor para realizar la accion que queremos probar.\nEn este caso, usamos la clase de Interaction ",(0,r.jsx)(a.code,{children:"Get"}),", que viene incluida con ",(0,r.jsx)(a.code,{children:"serenity-screenplay-rest"}),"."]}),"\n",(0,r.jsxs)(a.p,{children:["A continuacion verificamos la respuesta usando el metodo ",(0,r.jsx)(a.code,{children:"seeThatResponse"}),".\nEste metodo toma una expresion Lambda y nos permite acceder a la API completa de RestAssured.\nEn particular, podemos usar expresiones ",(0,r.jsx)(a.a,{href:"http://static.javadoc.io/io.restassured/json-path/3.1.0/io/restassured/path/json/JsonPath.html",children:"jsonPath"})," para consultar la estructura JSON que recibimos."]}),"\n",(0,r.jsx)(a.h3,{id:"recuperando-objetos",children:"Recuperando objetos"}),"\n",(0,r.jsx)(a.p,{children:"A veces necesitamos obtener un valor de una respuesta REST, y guardarlo para usarlo mas tarde. RestAssured hace relativamente facil convertir una estructura JSON a un objeto Java, que puedes usar mas adelante en tus tests."}),"\n",(0,r.jsx)(a.p,{children:"Por ejemplo, supongamos que tenemos una clase como la de abajo, que corresponde a los detalles de usuario devueltos por nuestro endpoint:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:"package examples.screenplay.rest.model;\n\npublic class User {\n    private String id;\n    private String first_name;\n    private String last_name;\n\n\n    public User(String first_name, String last_name) {\n        this.first_name = first_name;\n        this.last_name = last_name;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getFirstName() {\n        return first_name;\n    }\n\n    public String getLastName() {\n        return last_name;\n    }\n}\n"})}),"\n",(0,r.jsxs)(a.p,{children:["Podriamos recuperar el usuario como una instancia de esta clase llamando al metodo ",(0,r.jsx)(a.code,{children:"jsonPath().getObject()"})," en la respuesta recibida. Este metodo convertira los datos JSON en una ruta dada a una estructura Java correspondiente:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'@Test\npublic void retrieve_an_element_from_the_json_structure() {\n\n    sam.attemptsTo(\n            Get.resource("/users/1")\n    );\n\n    User user = SerenityRest.lastResponse()\n                            .jsonPath()\n                            .getObject("data", User.class);\n\n    assertThat(user.getFirstName()).isEqualTo("George");\n    assertThat(user.getLastName()).isEqualTo("Bluth");\n\n}\n'})}),"\n",(0,r.jsx)(a.h3,{id:"recuperando-listas",children:"Recuperando listas"}),"\n",(0,r.jsx)(a.p,{children:"A menudo necesitamos recuperar no un solo elemento, sino una lista de elementos.\nRecuperar una lista es poco diferente a recuperar un solo elemento:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'sam.attemptsTo(\n        Get.resource("/users")\n);\n\nsam.should(\n        seeThatResponse("all the expected users should be returned",\n                response -> response.body("data.first_name", hasItems("George", "Janet", "Emma")))\n);\n'})}),"\n",(0,r.jsxs)(a.p,{children:["La diferencia ocurre cuando consultamos los resultados.\nEn este caso, usamos una expresion jsonPath (",(0,r.jsx)(a.code,{children:"data.first_name"}),") que devolvera ",(0,r.jsx)(a.em,{children:"todos"})," los valores del campo first_name.\nEl Matcher Hamcrest ",(0,r.jsx)(a.code,{children:"hasItems"}),' comparara la coleccion de nombres devuelta por la consulta jsonPath, y verificara que contiene (al menos) los nombres "George", "Janet" y "Emma".']}),"\n",(0,r.jsxs)(a.p,{children:["Pero, que pasa si queremos capturar los datos que recuperamos, en lugar de simplemente hacer una asercion sobre el contenido?\nPodemos hacer eso usando el metodo ",(0,r.jsx)(a.code,{children:"SerenityRest.lastResponse()"}),", asi:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'List<String> userSurnames = SerenityRest.lastResponse().path("data.last_name");\nassertThat(userSurnames).contains("Bluth", "Weaver", "Wong");\n'})}),"\n",(0,r.jsxs)(a.p,{children:["Tambien podemos recuperar listas de objetos, tal como recuperamos una sola instancia de ",(0,r.jsx)(a.code,{children:"User"})," en la seccion anterior.\nSimplemente usa el metodo ",(0,r.jsx)(a.code,{children:"jsonPath.getList()"})," como se muestra a continuacion:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'sam.attemptsTo(\n        Get.resource("/users")\n);\n\nsam.should(\n        seeThatResponse("all the expected users should be returned",\n                response -> response.body("data.first_name", hasItems("George", "Janet", "Emma")))\n);\n'})}),"\n",(0,r.jsx)(a.h3,{id:"usando-parametros-de-ruta",children:"Usando Parametros de Ruta"}),"\n",(0,r.jsx)(a.p,{children:"En el ejemplo anterior, codificamos el elemento de ruta en la peticion.\nPara un enfoque mas flexible, podemos proporcionar el parametro de ruta cuando enviamos la consulta:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'sam.attemptsTo(\n        Get.resource("/users/{id}").with( request -> request.pathParam("id", 1))\n);\n'})}),"\n",(0,r.jsxs)(a.p,{children:["Aqui estamos usando la estructura ",(0,r.jsx)(a.code,{children:"Get.resource(...).with(...)"})," para pasar el objeto ",(0,r.jsx)(a.code,{children:"RequestSpecification"})," de RestAssured a una expresion lambda.\nUna vez mas, esto nos da acceso a toda la riqueza de la biblioteca RestAssured."]}),"\n",(0,r.jsx)(a.h3,{id:"usando-parametros-de-consulta",children:"Usando Parametros de Consulta"}),"\n",(0,r.jsxs)(a.p,{children:["Algunas APIs REST toman parametros de consulta ademas de parametros de ruta. Los parametros de consulta se usan comunmente para filtrar resultados o implementar paginacion. Por ejemplo, podriamos obtener la segunda pagina de usuarios de nuestra API ",(0,r.jsx)(a.code,{children:"/users"})," usando el parametro de consulta ",(0,r.jsx)(a.code,{children:"page"})," asi:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{children:"/users?page=2\n"})}),"\n",(0,r.jsxs)(a.p,{children:["En nuestro codigo de test, usamos el metodo ",(0,r.jsx)(a.code,{children:"queryParam()"})," para proporcionar un valor para el parametro ",(0,r.jsx)(a.code,{children:"page"}),":"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'sam.attemptsTo(\n        Get.resource("/users").with( request -> request.queryParam("page", 2))\n);\n\nsam.should(\n        seeThatResponse("All users on page 2 should be returned",\n                response -> response.body("data.first_name",\n                                     hasItems("Eve", "Charles", "Tracey")))\n);\n'})}),"\n",(0,r.jsx)(a.h2,{id:"consultas-post",children:"Consultas Post"}),"\n",(0,r.jsxs)(a.p,{children:["Podemos enviar peticiones POST a un endpoint REST usando la clase de Interaction ",(0,r.jsx)(a.code,{children:"Post"}),". Aqui hay un ejemplo simple:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'sam.attemptsTo(\n        Post.to("/users")\n                .with(request -> request.header("Content-Type", "application/json")\n                                        .body("{\\"firstName\\": \\"Sarah-Jane\\",\\"lastName\\": \\"Smith\\"}")\n                )\n);\n\nsam.should(\n        seeThatResponse("The user should have been successfully added",\n                        response -> response.statusCode(201))\n);\n'})}),"\n",(0,r.jsx)(a.p,{children:"Alternativamente, podemos publicar un objeto, dejando que RestAssured convierta los campos del objeto a JSON por nosotros:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'User newUser = new User("Sarah-Jane", "Smith");\n\nsam.attemptsTo(\n        Post.to("/users")\n                .with(request -> request.header("Content-Type", "application/json")\n                                        .body(newUser)\n                )\n);\n'})}),"\n",(0,r.jsx)(a.h2,{id:"otros-tipos-de-consultas",children:"Otros tipos de consultas"}),"\n",(0,r.jsxs)(a.p,{children:["Otros tipos de consultas son similares a las consultas ",(0,r.jsx)(a.code,{children:"GET"})," y ",(0,r.jsx)(a.code,{children:"POST"}),".\nPor ejemplo, las peticiones ",(0,r.jsx)(a.code,{children:"PUT"})," a menudo se usan para actualizar recursos.\nEn el siguiente ejemplo, usamos una peticion ",(0,r.jsx)(a.code,{children:"PUT"})," para actualizar los detalles de un usuario:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'sam.attemptsTo(\n        Put.to("/users")\n                .with(request -> request.header("Content-Type", "application/json")\n                        .body("{\\"firstName\\": \\"jack\\",\\"lastName\\": \\"smith\\"}")\n                )\n);\n\nsam.should(\n        seeThatResponse(response -> response.statusCode(200)\n                                            .body("updatedAt", not(isEmptyString())))\n);\n'})}),"\n",(0,r.jsxs)(a.p,{children:["O puedes eliminar un usuario usando la consulta ",(0,r.jsx)(a.code,{children:"DELETE"})," como se muestra aqui:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'sam.attemptsTo(\n        Delete.from("/users/1")\n);\n\nsam.should(\n        seeThatResponse(response -> response.statusCode(204))\n);\n'})}),"\n",(0,r.jsx)(a.h2,{id:"task-de-nivel-superior",children:"Task de nivel superior"}),"\n",(0,r.jsx)(a.p,{children:"Las Interaction que hemos visto hasta ahora son legibles pero aun bastante de bajo nivel.\nScreenplay nos permite construir Task de nivel superior que representan la intencion de negocio detras de estas Interaction."}),"\n",(0,r.jsx)(a.p,{children:"Por ejemplo, podrias definir un Task que encapsula listar todos los usuarios asi:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'package examples.screenplay.rest.tasks;\n\nimport net.serenitybdd.screenplay.Task;\nimport net.serenitybdd.screenplay.rest.interactions.Get;\n\npublic class UserTasks {\n    public static Task listAllUsers() {\n        return Task.where("{0} lists all users",\n                Get.resource("/users")\n        );\n    }\n}\n'})}),"\n",(0,r.jsx)(a.p,{children:"Luego podemos usar un import estatico para refactorizar nuestro primer test de la siguiente manera:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:"sam.attemptsTo(\n        listAllUsers()\n);\n"})}),"\n",(0,r.jsxs)(a.p,{children:["Para un poco mas de flexibilidad, tambien podemos escribir una clase ",(0,r.jsx)(a.code,{children:"Task"})," personalizada. Por ejemplo, podriamos escribir un Task ",(0,r.jsx)(a.code,{children:"FindAUser"})," para encontrar un usuario por ID:"]}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:'package examples.screenplay.rest.tasks;\n\nimport net.serenitybdd.screenplay.Actor;\nimport net.serenitybdd.screenplay.Task;\nimport net.serenitybdd.screenplay.rest.interactions.Get;\nimport net.thucydides.core.annotations.Step;\n\nimport static net.serenitybdd.screenplay.Tasks.instrumented;\n\npublic class FindAUser implements Task{\n    private final int id;\n\n    public FindAUser(int id) {\n        this.id = id;\n    }\n\n    public static FindAUser withId(int id) {\n        return instrumented(FindAUser.class, id);\n    }\n\n    @Override\n    @Step("{0} fetches the user with id #id")\n    public <T extends Actor> void performAs(T actor) {\n        actor.attemptsTo(\n                Get.resource("/users/{id}")\n                   .with(request -> request.pathParam("id", id))\n        );\n    }\n}\n'})}),"\n",(0,r.jsx)(a.p,{children:"Usando esta clase, podriamos refactorizar nuestra clase original para que se lea asi:"}),"\n",(0,r.jsx)(a.pre,{children:(0,r.jsx)(a.code,{className:"language-java",children:"sam.attemptsTo(\n        FindAUser.withId(1)\n);\n"})}),"\n",(0,r.jsx)(a.p,{children:"Usar Task para encapsular Interaction REST resulta en una estructura de reportes clara y en capas, que primero describe lo que el usuario esta haciendo, y luego como lo hace. El reporte de prueba para el Scenario anterior se muestra aqui:"}),"\n",(0,r.jsx)(a.p,{children:(0,r.jsx)(a.img,{src:n(3463).A+"",width:"1770",height:"744"})})]})}function u(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453(e,a,n){n.d(a,{R:()=>i,x:()=>t});var s=n(6540);const r={},o=s.createContext(r);function i(e){const a=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function t(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:a},e.children)}}}]);